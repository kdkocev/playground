#include<iostream>
#include<cstdlib>
#include<cstring>
using namespace std;

// Клас Point, където ще обясним на компютъра какво за нас означава точка
class Point{
    private:
        // Атрибутите на класа ще са ни координатите на точката
        // Вместо float, можем да ползваме и double
        float x;
        float y;
    public:
        // Конструктор за класа Point.
        // Конструктора в c++ се дефинира като функция, без тип, и с името на класа
        // Този конструктор не очаква аргументи. Нарича се: конструктор по подразбиране (default constructor)
        Point(){
            set_x(0);
            set_y(0);
        }
        // Този конструктор очаква 2 аргумента, координатите на точката
        Point(float x, float y){
            // Вместо да викаме set функциите на атрибутите, можем и просто да напишем:
            // this->x = x;
            // Но тъй като set функциите се използват,
            // за защита на входните данни е по-добре да преизползваме защитата, която сме описали там
            // вместо да я пишем на повече от едно място. Защото при евентуална промяна в 
            // логиката - ще трябва да се сетим да я поправим на 2 места, вместо само в set функцията
            set_x(x);
            set_y(y);
        }
        // set функция за атрибута x, използва се за защита на входа за x ако е нужна такава
        void set_x(float x){
            this->x = x;
        }
        // get функция за x атрибута. Използва се за даване на стойността на променливата, без да се дава възможност за промяна.
        float get_x(){
            return x;
        }
        void set_y(float y){
            this->y = y;
        }
        float get_y(){
            return y;
        }
};

// Предефиниране на оператора << или още казано:
// ostream operator overloading
// ostream - output stream (изходен поток)
// Входа и изхода cin, cout в c++ се наричат потоци
// Ако искаме да можем да използваме стандартните cin, cout
// със обекти от нашия клас - можем да опишем на компютъра
// точно как искаме да става това с помощта на тази функция.
// "Сигнатурата" на функцията е винаги една и съща:
// ostream & operator << (ostream & os, <вашият клас> T);
// и винаги след като добавим нещата, които искаме - към потока os,
// трябва да върнем потока обратно:
// return os;
// 
// Интересен факт е, че не можем да опишем тази функция вътре в класа.
// Причината за това е, че тази функция изисква винаги като първи параметър да и бъде
// подаден потокът, към който ще пишем,
// а всички функции (методи) в класа имат подаден this параметър като първи по премълчаване.
// Това поражда конфликт и нужда функциите от този тип (ostream и istream) да бъдат дефинирани
// извън класът.
ostream & operator << (ostream & os, Point A){
    os<<"("<<A.get_x()<<","<<A.get_y()<<")";
    return os;
}

// Предефиниране на оператора +
// направихме го с цел да покажем че можем да предефинираме
// всички оператори в c++, не само за вход и изход (>>, <<)
// Сигнатурата на тази функция отново винаги се запазва.
// Тази функция може да бъде дефинирана и като вътрешна за класа ни.
Point operator + (Point lhs, Point& rhs)
{
  float x = lhs.get_x() + rhs.get_x();
  float y = lhs.get_y() + rhs.get_y();
  return Point(x,y);
}

// Тази функция намира вектор(разстоянието) между точката A и точката B
// написахме я за да покажем как можем да използваме нашият тип "Point"
// както всеки друг първичен тип в c++, било то като тип на функция, променлива и тн.
Point dist(Point A, Point B){
    float dist_x = A.get_x() - B.get_x();
    float dist_y = A.get_y() - B.get_y();
    return Point(dist_x, dist_y);
}

// Тази функция намира вектор - сумата на векторите A и B
// Нека думата вектор не ви плаши. Тя е същата като думата "Точка" в нашия смисъл,
// защото приемаме че всички вектори започват от точката (0,0) и имат координати x,y
Point add(Point A,Point B){
    float dist_x = A.get_x() + B.get_x();
    float dist_y = A.get_y() + B.get_y();
    return Point(dist_x, dist_y);
}

// Клас String - домашната ви.
// Задачата ви е да реализирате същия String, който познавате от c# и c++
class String{
    private:
        // Указател към масив от char
        char *s;
    public:
        // Конструктор за String
        // приема аргумент - низ
        String(char a[]){
            // заделя динамична памет за s - колкото е дължината на a
            s = new char[strlen(a) + 1];
            // копира а в s
            for(int i=0;i<strlen(a);i++){
                s[i] = a[i];
            }
        }

        // Метод, който до добавя низът "а" към текущия обект
        void append(char a[]){
            // Трябва отново да заделите памет, голяма колкото 2та низа заедно +1
            char *temp = new char[strlen(s) + strlen(a) + 1];
            // да копираме всеки символ от s и a в новата променлива temp
            //....

            // да насочим указателя s към променливата temp
            s = temp;
        }

        // тривиален print метод
        void print(){
            cout<<s<<endl;
        }

        // Деструктор за String
        // Той освобождава заетата динамична памет при унищожаване на обекта
        ~String(){
            delete [] s;
        }
};


int main(){
    // Разни тестове, които сме писали
    String s("kamen");
    s.print();

    Point A(1,2), B(4,10);
    cout<<A.get_x()<<" "<<A.get_y()<<endl;

    cout<<A<<endl;
    cout<<A + B<<endl;

    //cout<<dist(A, B).get_x()<<" "<<dist(A, B).get_y()<<endl;
    return 0;
}
